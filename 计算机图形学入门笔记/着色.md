# 着色

## Blinn-Phong反射模型
### 三个要素
+ 镜面高光
+ 漫反射
+ 环境光
### 数学模型
$$
\begin{align}
基础定义:\\
\vec{v}:观察者方向(单位向量)\\
\vec{n}:法线方向(单位向量)\\
\vec{I}:光线方向(单位向量)\\
（以上方向均以着色点为起点）\\
其他的表面参数：颜色、衰减等\\

\end{align}
$$
### 漫反射
光线打到目标点之后向所有方向发出的反射光
#### Lambert定律
将光线视为一条一条的射线，则物体接收到的能量即投射到其上的光线的数量，光线与法线方向重合时接收到所有的光线，即：
$$
cos\theta=\vec{I}\cdot\vec{n}
$$
#### 衰减
可以认为光源发出的能量永远均匀分布在一个球壳上，则离光源越远球壳越大，且与球壳的面积有关（平方反比），即
$$
I(r)=\frac{I_0}{r^2}
$$
#### 漫反射计算
综合上面两个因素，得到漫反射的计算公式为：
$$
L_d=k_d(\frac{I_0}{r^2})max(0,\vec{n}\cdot\vec{I})
$$
其中，max是为了保证反向的光线不产生影响，$k_d$为漫反射参数，表示的是物体本身吸收了多少漫反射能量
这个式子假定，漫反射与观察方向无关，只与光源方向有关。
### 高光
高光表示了物体表面按光的反射定律反射出去的光，反射向量与观察方向越接近，观察者接收到的高光就越多。
#### 半程向量
用于减小计算反射角与观察方向的巧妙方法
半程向量即光线方向与观察方向所形成角的角平分线方向，数学表示为：
$$
\vec{h}=\frac{\vec{v}+\vec{I}}{||\vec{v}+\vec{I}||}
$$

推导如下：
用角度来表示向量所代表的方向，并选取一个与法线垂直的轴作为0角度：
$$
\theta(\vec{x})：表示以某个轴为0角度，向量\vec{x}与该轴的夹角
$$
则观察方向与反射方向$\vec{I}'$的夹角为：
$$
\Delta\theta=|\theta(\vec{I}')-\theta(\vec{v})|
$$
由反射方向与入射方向的角关系：
$$
\theta(\vec{I}')=\pi-\theta(\vec{I})
$$
带入得：
$$
\Delta\theta=|\pi-\theta(\vec{I})-\theta(\vec{v})|
$$
而半程向量：
$$
\theta(\vec{h})=\frac{\theta(\vec{I})+\theta(\vec{v})}{2}
$$
其与法线得夹角为：
$$
\Delta\theta'=|\frac{\pi}{2}-\theta(\vec{h})|=\frac{|\pi-\theta(\vec{I})-\theta(\vec{v})|}{2}=\frac{\Delta\theta}{2}
$$
以上推导将反射方向与视线方向的关系转化为法线与半程向量的关系

#### 高光计算
由上推导，高光的计算公式为：
$$
L_s=k_s(\frac{I_0}{r^2})max(0,\vec{n}\cdot\vec{h})^p
$$
指数$p$为来控制高光的范围，指数越高，高光范围越小，正常情况可能用到p为100-200
而系数$k_r$则为高光的亮度系数

### 环境光
环境光假设所有点收到的环境光都是相同的，简化计算为：：
$$
L_a=k_a\cdot I_a
$$
完全为一个常数

### 总计算公式
$$
L=L_a+L_d+L_s
$$
## Shading Frequencies
着色频率表示着色具体应用在哪些点上
### Flat Shading（基于面的着色）
每一个三角形只使用一个法向向量进行着色计算，得到的结果用于整个三角面
不适用于光滑的物体
### Gouraud Shanding（基于顶点的着色）
每一个顶点进行着色计算，得到的结果插值到每一个三角面内的像素上
### Phong Shading（基于像素的着色）
每个像素利用其对应三角面的法线进行插值，根据像素的法线方向进行着色计算，可以得到一个很好的结果
### 顶点法线计算
顶点的法线一般使用其相邻的面的法向的加权平均
### 逐像素法线计算
使用重心坐标进行插值

## 重心坐标（Barycentric Coordinates）插值
将三角形中某个点表示为其三个角坐标的线性组合
$$
D=\alpha A+\beta B+\gamma C(\alpha+\beta+\gamma=1)
$$
从而用数对$(\alpha,\beta,\gamma)$来表示一个三角形内的点的坐标
在三角形内的点满足一个性质：
$$
0<\alpha,\beta,\gamma<1
$$
由奔驰定理，重心坐标可以表示某个点与三个顶点连线分出来的三个三角形的面积比（重心坐标分量的值表示顶点对面的小三角形面积与整个三角形的面积的比），这个性质用于计算任意一点的重心坐标。

当三个参数都取$\frac{1}{3}$时，表示的点即为三角形的重心

重心坐标并不能保证在投影变换下不被改变（投影后重心坐标需要重新计算）

## Texture Magnification
将低分辨率的纹理应用到高分辨率的情况需要进行纹理的放大
### Nearest
取最近的纹素，会造成不连续的、格子状的观感
### Bilinear Interpolation
寻找映射点最临近的四个纹素中心位置，即$u_{00},u_{01},u_{10},u_{11}$（分别对应左下，左上，右下，右上的最邻近纹素坐标）
以$\overrightarrow{u_{00}u_{10}}$为s轴，得到映射点s坐标，同理得到t坐标
由$s,t$以及四个纹素坐标进行两次线性插值，如下：
$$
\begin{align}
u_0=lerp(s,u_{00},u_{10})\\
u_1=lerp(s,u_{01},u_{11})\\
f(x,y)=lerp(t,u_0,u_1)
\end{align}
$$
### Bicubic Interpolation
取周围临近的16个纹素进行三次线性插值，原理相同

### MipMap
#### 问题
如果渲染结果分辨率过小，纹理分辨率过大，如果使用Nearest方法就会产生严重的摩尔纹（本质上是采样率远小于信号变化率导致的）
使用MipMqp技术可以解决这个问题

MipMap可以事先计算纹理某个区域的平均值，在渲染时可以直接查询低分辨率的MipMap

#### 计算
由于每一层的mipmap分辨率都为前面的$\frac{1}{4}$，故所有层级的MipMap所使用的存储空间为$1+\frac{1}{4}+\frac{1}{4^2}+\frac{1}{4^3}+...=\frac{4}{3}$
即额外的储存空间不会超过原有的$\frac{1}{3}$

为了使用MipMap，我们需要计算当前像素对应第几个等级的MipMap。计算方法如下：

### Anisotropic Filtering（各向异性过滤）
MipMap三线性插值会在高层级的地方出现过于模糊的问题，各向异性过滤来可以部分避免这样的问题。

各向异性过滤的思想是：比MipMap多保存了分辨率宽（高）不变，只缩小高（宽）的平均结果。从而避免了之前的问题