# 游戏引擎并行架构
## 静态的多线程（Fixed Multi-Thread）
为每一种类的任务分配一个线程，整个游戏引擎分为渲染线程、模拟线程、逻辑线程等各自分别相对独立进行
问题：造成了计算资源的浪费，因为固定的线程数很有可能和实际上CPU核数不匹配，或者是线程之间的负载不均衡
## 动态的线程分配（Thread Fork-Join）
先是一个单线程运行，当这个线程派生出很多可并行的任务时，将这些任务分配到不同的核当中去执行，执行结束之后再回到单线程状态
## Task-Graph
预先规定好任务之间的依赖（静态），分配器根据依赖的拓扑序来自动分配任务给各个线程
问题：由于所有任务的依赖并不一定都能预先确定，因此这种方法不是很灵活

# JobSystem
## Fiber-based Job System
将Job塞到被称为Fiber的单元（实际上是一种协程）中，尽量使每个Fiber对应一个核（或者对应一个执行线程）
Job由一个Scheduler进行调度，对于每一个正在执行的Job来说，如果派生出更多的子Job，就将这些子Job交给Scheduler进行调度而非使用当前占用的线程执行子Job。
一般来说，派生出的子Job调度优先级要高于父Job，对于这样的情况，把父Job进入Waiting状态，限制性其依赖的子Job，等子Job执行完之后再执行父Job。
对于负载不均衡的情况，允许空闲线程将其余线程分配到但尚未开始执行的Job“偷”过来进行执行，从而提高效率。
优点：
+ 容易实现任务的调度
+ 可以解决任务之间的依赖问题
+ 任务之间的执行是隔离开的
+ 不需要频繁的上下文切换
缺点：
+ 原生C++并不支持协程机制
+ 协程的实现对于不同操作系统是不同的
+ 容易产生并行带来的各种问题

# 编程范式
## 面向对象的缺陷
+ 容易产生二义性：尤其是在两个对象之间的交互的时候，代码写在主动方还是被动方？
+ 方法在继承不同层次的分配：一个方法到底是每个子类都放还是放在父类
+ 胖基类：基类为了支持不同类型的子类，需要有很多繁杂的代码，但是每一个子类只会用到其中的一小部分（Unreal的Actor类）
+ 性能问题：对象在内存中是分散分布的，加上虚函数等机制使得代码执行时会内存中跳来跳去
+ 可测试性：测试某一个功能模块时，需要将对象创建出来，因此测试时必须启动所有的模块

# Data-Oriented Programming
面向数据编程一定程度上时基于CPU速度与访存速度不匹配的矛盾而产生的，希望数据尽可能的私有化和尽可能多的使用Cache。
DOP需要解决以下两个问题：
+ 数据访问尽可能一致，也就是同一时间会使用到的数据在内存中也尽可能的挨在一起，使得他们可以一起加载到Cache中从而提高速度
+ 代码分支尽可能一致，同一个分支指令尽可能跳转到同一个分支，使得流水线中的分支预测准确率更高从而减少代码的跳转
DOP的目标就是将SISD的系统重新组织成变成类似SIMD的系统。
### Array of structure和Structure of array
AOS将不同类型的数据并排成为数组，而SOA将同种类型的数据数组形成结构体。使用SOA可以使数据访问尽可能一致。

# Entity-Component-System
+ Entity：一个ID，Component可以依附于其上进行组合
+ Component：纯数据，不含业务逻辑
+ System：横向收集和处理数据，不一定只处理一种类型的Component的数据，可以处理多种类型的数据
## Unity DOTS
Unity DOTS有三个支柱，ECS,C# Based Job System,Burst Compiler
## Unreal Mass
和DOTS类似
